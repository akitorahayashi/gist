<!DOCTYPE html>
<html>
  <head>
    <title>Web Page Scraper</title>
  </head>
  <body>
    <h1>Enter URL to Scrape</h1>
    <form id="scrape-form">
      {% csrf_token %}
      <input
        type="url"
        name="url"
        id="url-input"
        size="50"
        placeholder="https://example.com"
        required
      />
      <button type="submit" id="submit-button">Scrape</button>
    </form>

    <div id="result-area" style="margin-top: 20px" aria-live="polite">
      <!-- 結果はここに表示されます -->
    </div>

    <script>
      const scrapeForm = document.getElementById("scrape-form");
      const urlInput = document.getElementById("url-input");
      const submitButton = document.getElementById("submit-button");
      const resultArea = document.getElementById("result-area");
      // Djangoで逆引きしたURLテンプレート（__TASK_ID__ を後で置換）
      const statusUrlTemplate = "{% url 'gist:get_status' task_id='__TASK_ID__' %}";
      let pollingInterval;
      let pollingAbortController;
      const POLLING_INTERVAL_MS = 2000;
      const MAX_POLLS = 150; // 5 minutes (2000ms * 150)

      scrapeForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const url = urlInput.value;
        const csrfToken = document.querySelector(
          "[name=csrfmiddlewaretoken]"
        ).value;

        // 以前の結果をクリアし、処理中メッセージを表示
        clearResult();
        showLoading("タスクを開始しています...");
        submitButton.disabled = true;

        try {
          // タスク開始APIを呼び出し
          const startResponse = await fetch("{% url 'gist:start_task' %}", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": csrfToken,
            },
            body: JSON.stringify({ url }),
          });

          if (startResponse.status === 202) {
            const data = await startResponse.json();
            // ポーリングを開始
            startPolling(data.task_id);
          } else {
            let msg = "タスクを開始できませんでした。";
            try {
              if ((startResponse.headers.get("content-type") || "").includes("application/json")) {
                const errorData = await startResponse.json();
                msg = errorData.error || msg;
              } else {
                msg = await startResponse.text();
              }
            } catch (_) { /* no-op: 既定文言を使用 */ }
            showError(`エラー (${startResponse.status}): ${msg}`);
            stopPolling(); // stopPollingはボタンを有効化するのでここで呼ぶ
          }
        } catch (error) {
          showError("ネットワークエラーが発生しました。");
          stopPolling();
        }
      });

      function startPolling(taskId) {
        stopPolling(); // Start with a clean state
        pollingAbortController = new AbortController();
        let pollCount = 0;

        showLoading("処理中です... ⏳");
        pollingInterval = setInterval(async () => {
          if (pollCount++ >= MAX_POLLS) {
            stopPolling();
            showError("タイムアウトしました。しばらくしてから再度お試しください。");
            return;
          }

          try {
            const statusUrl = statusUrlTemplate.replace("__TASK_ID__", encodeURIComponent(taskId));
            const statusResponse = await fetch(statusUrl, { signal: pollingAbortController.signal });

            if (!statusResponse.ok) {
              stopPolling();
              showError(`ステータスの取得に失敗しました (HTTP ${statusResponse.status})。`);
              return;
            }

            const data = await statusResponse.json();

            if (data.status === "success") {
              stopPolling();
              showSuccess(data.title, data.summary);
            } else if (data.status === "error") {
              stopPolling();
              showError(data.message);
            } else if (data.status === "processing") {
              showLoading(data.message + " ⏳");
            } else {
              // Fallback for unknown states
              showLoading("処理状況を取得しています... ⏳");
            }
          } catch (error) {
            if (error.name === 'AbortError') {
              // Polling was intentionally stopped, do nothing.
              return;
            }
            stopPolling();
            showError("ステータス確認中にエラーが発生しました。");
          }
        }, POLLING_INTERVAL_MS);
      }

      function stopPolling() {
        if (pollingInterval) {
          clearInterval(pollingInterval);
          pollingInterval = undefined;
        }
        if (pollingAbortController) {
          pollingAbortController.abort();
          pollingAbortController = undefined;
        }
        submitButton.disabled = false;
      }

      function clearResult() {
        resultArea.replaceChildren();
      }

      function showLoading(message) {
        resultArea.replaceChildren();
        const p = document.createElement("p");
        p.textContent = message;
        resultArea.appendChild(p);
      }

      function showError(message) {
        resultArea.replaceChildren();
        const h2 = document.createElement("h2");
        h2.textContent = "エラー:";
        const p = document.createElement("p");
        p.style.color = "red";
        p.textContent = message;
        resultArea.appendChild(h2);
        resultArea.appendChild(p);
      }

      function showSuccess(title, summary) {
        resultArea.replaceChildren();
        const h2 = document.createElement("h2");
        h2.textContent = "要約:";
        const h3 = document.createElement("h3");
        h3.textContent = title;
        const pre = document.createElement("pre");
        pre.style.whiteSpace = "pre-wrap";
        pre.textContent = summary;
        resultArea.appendChild(h2);
        resultArea.appendChild(h3);
        resultArea.appendChild(pre);
      }
    </script>
  </body>
</html>
